% !TEX root =  master.tex
\section{Testverfahren}
\authorsection{\authorEJ}

Testen wird oftmals als Prozess, der aufzeigen soll, dass keine Fehler in dem Programmcode vorhanden sind, fehl verstanden.
Im eigentlichen Sinne geht es dabei nicht darum zu zeigen, dass der Quellcode fehlerfrei ist, sondern das er Fehler enthält und nach diesen gesucht werden muss.\footnote{\url{http://www.knaupes.net/theorie-der-softwaretests/}}

\subsection{Testprinzipien}
Aufgrund dieser Definition für Testen müssen Ausgangsvoraussetzungen gegeben sein, um eine möglichst umfangreiche Testabdeckung gewährleisten zu können.
Zu diesen zählen das Feststellen, ob der Quellcode genau die Anforderungen erfüllt und sonst auch keine weiteren Eventualitäten abdeckt.
Ebenfalls sollte dabei genau dokumentiert werden, welcher Testfall bereits abgedeckt wurde, da bei vielen unterschiedlichen Testfällen und einem größeren Testpensum der Überblick schnell verloren werden kann.
Des Weiteren müssen Testfälle reproduzierbar sein und es darf sich nicht um ein einzelnes Phänomen handeln.
Einen Testfall zu generieren, der aber eigentlich gar nichts mit dem zu testenden Quellcode zu tun hat, ist einerseits nicht möglich und andererseits nicht sinnvoll.
Der aber wohl wichtigste Punkt, ob fachlich oder menschlich gesehen, ist jedoch, dass der Tester nicht der Programmierer selbst sein darf.
% TODO: streitbare Aussage (normalerweise wird der Test geschrieben, bevor der entsprechende Code vorhanden ist; dadurch ist die folgende Argumentation teilweise hinfällig)
Als Programmierer des Quellcodes besitzt man eine voreingenommene Meinung, der Quellcode hat genau einen Zweck und diesen erfüllt er für den Programmierer auch.
Daher kann ein größerer Blickwinkel auf den Quellcode leider nicht gewährleistet werden und die Testfälle können nicht in hinreichender Genauigkeit generiert werden.
Ebenfalls hat ein Tester auch keine leichte Aufgabe, da er sich in den Quellcode des Programmierers einarbeiten und diesen testen muss.
Damit ist es aber noch nicht getan, da der Tester nun den Fehler weitergeben muss.
Das absichtliche Suchen nach Fehlern und der Drang nach Perfektionismus ist zwar notwendig, kann aber schnell zu zwischenmenschlichen Konflikten führen.
Deshalb ist sowohl auf Tester- und Programmierseite Vorsicht und auch Verständnis für die Aufgabe des Gegenparts geboten.

\subsection{Äquivalenzklassen}
Da selbst bei einem einfachen Test die möglichen Testfälle unmöglich viele werden können, kann durch die Äquivalenzklassen Abhilfe geschaffen werden.
Diese Äquivalenzklassen verhalten sich gleich wie die getesteten Eingabedaten, daher kann man davon ausgehen, dass diese Testfälle ebenfalls abgedeckt wurden.
In diesem Sinne reicht es die Grenzfälle zu testen und bei allen anderen Möglichkeiten von einer äquivalenten Verhaltensweise auszugehen.\footnote{\url{https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2010_2011/siw-1011-ehmke-tests-ausarbeitung.pdf}}
Um dies mit einem Beispiel zu erläutern, könnte man die Subtraktion von zwei Zahlen heranziehen.
Wenn also die Subtraktion von Zahlen in einem Testfall funktioniert hat, dann kann man davon ausgehen, dass die anderen möglichen Testfälle mit Eingabedaten des gleichen Datenformates und Datentyps auch ein positives Ergebnis zurückgeben werden.

\subsection{Testebenen}
Das Testen von Quellcode kann in vielen Weisen passieren.
Einerseits kann der Quellcode an sich getestet und damit jede einzelne Komponente einer Anwendung überprüft werden, auch Komponententests bezeichnet.
Diese Ebene kann durch ein besonderes Designparadigma auch zur leitenden Kraft der Softwareentwicklung werden, dies ist die testgetriebene Softwareentwicklung.
Dabei wird meistens Nutzen aus den Vorteilen einer agilen Softwareentwicklung gezogen, um am Ende ein Konglomerat von positiven Effekten zu erhalten.
Diese stellen sich durch höhere Qualität, niedrigere Wartungsarbeiten, saubere Struktur und effektive Vermeidung von Redundanzen ein.\footnote{\url{https://de.ryte.com/wiki/Test_Driven_Development}}

Auf der nächsten Stufe folgen dann die Integrationstests. Diese sind dazu da, um Redundanzen innerhalb des Projektes aufzudecken.
Ebenfalls können nicht eindeutige Spezifikationen der Klassen bemerkt und ausgemerzt werden.

Danach kommen noch die System- und Abnahmetests, diese sind beide durch einen gemeinsamen Nenner definiert.
Beiderseits wird die Prüfung nach der Zufriedenstellung der Systemanforderungen realisiert.
In Detail handelt es sich bei den Systemtests um diverse Performance-, Installations-, Wiederinbetriebnahme-, Stress- und Usability-Tests.
Auf der anderen Seite wird bei einem Abnahmetest geprüft, ob die Anforderungen eines Benutzers erfüllt werden und die Funktionalität, User Experience und Dokumentation in einer angemessenen Art und Weise erfüllt wurden.\footnote{\url{https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2010_2011/siw-1011-ehmke-tests-ausarbeitung.pdf}}

\subsection{White-Box-Test und Black-Box-Test}
Bei beiden Testformen handelt es sich um eine Art den Quellcode auf seine Struktur, Design und Implementation zu testen.
In einem Black-Box-Test hingegen ist der zu testende Code nicht bekannt und dies ist auch nicht erwünscht.
Es handelt sich um eine einfache und billige Art und Weise das System zu testen.
Der Programmierer muss dabei keinerlei Kenntnisse von der Implementierung haben, sondern lediglich die Anforderungen an das System kennen.
Die möglichen Testmethoden sind Akzeptanz- und System-Tests, also Tests, ob die Anforderungen des Benutzers und die Anforderungen an das System erfüllt wurden.
Als Beispiel kann man sich einen Tester für ein Kinobuchungssystem vorstellen, der als Testfall das Buchen von Eintrittskarten heranzieht.
Er besitzt weder Kenntnisse über das System, noch hat er eine konkrete Ahnung, welche Brennpunkte in dem System existieren und wird diese auch nicht explizit testen.

Im Gegensatz dazu gibt es noch die White-Box-Test.
Dabei handelt es sich um das Gegenteil eines Black-Box-Tests.
Diese Methode ist im Gegensatz zu einem Black-Box-Test teurer und aufwendiger, aber führt zu einer genaueren Testabdeckung.
Der Tester hat detaillierte Kenntnisse über das System und hat Einblick in alle Ressourcen, die den Quellcode betreffen.
Die Testmethoden eines White-Box-Testers sind Unit-Tests und Integrationstests, also Test auf die Verwendung von Codeabschnitten und einzelnen Codezeilen.
Das Beispiel für einen solchen Test wäre ein Tester, der jede Zeile eines Kinobuchungssystems auf Herz und Nieren testet.
