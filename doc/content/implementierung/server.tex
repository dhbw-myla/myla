% !TEX root =  ../../master.tex
\section{Server}

\subsection{Grundlegender Aufbau}
Zur Implementierung der Geschäftslogik wird ein Webserver mit Node.js in Verbindung mit dem Framework Express entwickelt.
Bei Node.js handelt es sich um eine JavaScript-Laufzeitumgebung, die die serverseitige Entwicklung mit JavaScript ermöglicht und dabei auf der V8-JavaScript-Implementierung von Google aufsetzt.\autocite[Vgl.][]{nl-openjsfoundation2020nodejs}
Express ist ein Framework für Node.js, um Webanwendungen und \acsp{API} zu entwickeln und wegen der Einfachheit weit verbreitet.\autocite[Vgl.][]{nl-strongloop2017express}

Für die Datenhaltung wird PostgreSQL, ein \ac{RDBMS}, verwendet.
Wie bei allen \acs{RDBMS} können Daten über die Sprache \acs{SQL} abgefragt und editiert werden. % for some unknown reason \acsp doesn't create a hyperlink here
Mithilfe eines entsprechenden Moduls kann sich innerhalb der Node.js-Anwendung mit der PostgreSQL-Datenbank verbunden werden, sodass \acs{SQL}-Befehle ausgeführt werden können.\autocite[Vgl.][]{nl-carlson2020nodepostgres}

Für jeden \acs{API}-Endpunkt wird jeweils eine Funktion aufgerufen, die die übergebenen Daten entgegennimmt, prüft und daraufhin auf die Datenbank zugreift.

\subsection{Zugriffskontrolle}
Die Zugriffskontrolle erfolgt im Back-End.
Da jegliche Kontrolle, die im Front-End implementiert ist, clientseitig ausgeführt wird, ist sie auch durch einen Angreifer ohne Weiteres aufzuheben und damit als unsicher anzusehen.
Nichtsdestotrotz sind natürlich auch im Front-End entsprechende Maßnahmen implementiert.
Diese dienen allerdings nicht dem Schutz gegen unbefugte Zugriffe, sondern sollen lediglich dafür sorgen, dass Nutzer bereits in der graphischen Darstellung erkennen, wozu sie berechtigt sind und worauf sie Zugriff haben.
Alles andere führt für Benutzer nur zu Verwirrung.

Für die tatsächliche Zugriffskontrolle im Back-End werden, wie bereits in der Konzeption in Abschnitt~\ref{sec:authentifizierung} erläutert, Passwörter beziehungsweise Session-IDs genutzt.
Bei der Registrierung oder einer Anmeldung wird eine solche Session-ID ausgestellt.
Bei jedem Zugriff auf einen der \acs{API}-Endpunkte wird, bevor überhaupt irgendeine Aktion ausgeführt wird, die Korrektheit dieser Session-ID geprüft.
Damit ist sichergestellt, dass eine entsprechende Prüfung nicht versehentlich beim Implementieren eines einzelnen \acs{API}-Endpunkts vergessen werden kann.

So wird dabei zunächst der Nutzername und die Session-ID ausgelesen aus der Anfrage an das Back-End ausgelesen.
Daraufhin kann nach einem entsprechenden Eintrag in der Datenbank gesucht werden.
Wird kein Ergebnis gefunden, ist die übergebene Session-ID also nicht für den entsprechenden Benutzer gespeichert, so ist der Nutzer nicht berechtigt und die Anfrage wird zurückgewiesen.
Der Zugriff wird auch dann verwehrt, wenn ein Passwortwechsel gefordert ist.
Somit wird dieser Passwortwechsel, z.~B. nach einem Zurücksetzen des Passworts, durchgesetzt und kann nicht umgangen werden.

Selbstverständlich gibt es auch \acs{API}-Endpunkte, auf die Zugriffe ohne Autorisierung möglich sein müssen.
Dies umfasst einerseits das Beantworten von Umfragen und andererseits das Registrieren, Passwortwechseln und Anmelden, bei dem Nutzer logischerweise noch keine gültige Session-ID besitzen, da sie diese ja dadurch erst erhalten wollen.
Entsprechende Ausnahmen sind über eine Whitelist gelöst, sie werden also explizit aufgelistet.
Auch hierbei steht im Vordergrund, dass \acs{API}-Endpunkte standardmäßig geschützt sind und nicht versehentlich Sicherheitslücken entstehen.

Darüber hinaus wird bei jeder Aktion die Berechtigung geprüft.
Bei der Bearbeitung eines \texttt{SurveyMasters} wird zum Beispiel zuerst einmal validiert, ob dieser auch dem angemeldeten Nutzer zugeordnet ist.

Ebenso gibt es Aktionen, die nur durch Administratoren durchgeführt werden können.
Dies umfasst das Lesen, Aktivieren, Bearbeiten und Deaktivieren des Registrierungsschlüssels, das Erstellen von Benutzern, das Zurücksetzen von Passwörtern und das Erstellen weiterer Administratoren.
