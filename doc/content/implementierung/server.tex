% !TEX root =  ../../master.tex
\section{Server}

\subsection{Grundlegender Aufbau}
Zur Implementierung der Geschäftslogik wird ein Webserver mit Node.js in Verbindung mit dem Framework Express entwickelt.
Bei Node.js handelt es sich um eine JavaScript-Laufzeitumgebung, die die serverseitige Entwicklung mit JavaScript ermöglicht und dabei auf der V8-JavaScript-Implementierung von Google aufsetzt.\autocite[Vgl.][]{nl-openjsfoundation2020nodejs}
Express ist ein Framework für Node.js, um Webanwendungen und \acsp{API} zu entwickeln und wegen der Einfachheit weit verbreitet.\autocite[Vgl.][]{nl-strongloop2017express}

Für die Datenhaltung wird PostgreSQL, ein \ac{RDBMS}, verwendet.
Wie bei allen \acsp{RDBMS} können Daten über die Sprache \acs{SQL} abgefragt und editiert werden.
Mithilfe eines entsprechenden Moduls kann sich innerhalb der Node.js-Anwendung mit der PostgreSQL-Datenbank verbunden werden, sodass \acs{SQL}-Befehle ausgeführt werden können.\autocite[Vgl.][]{nl-carlson2020nodepostgres}

Für jeden \acs{API}-Endpunkt wird jeweils eine Funktion aufgerufen, die die übergebenen Daten entgegennimmt, prüft und daraufhin auf die Datenbank zugreift.

\subsection{Zugriffskontrolle}
Die Zugriffskontrolle erfolgt im Back-End.
Da jegliche Kontrolle, die im Front-End implementiert ist, clientseitig ausgeführt wird, ist sie auch durch einen Angreifer ohne Weiteres aufzuheben und damit als unsicher anzusehen.
Nichtsdestotrotz sind natürlich auch im Front-End entsprechende Maßnahmen implementiert.
Diese dienen allerdings nicht dem Schutz gegen unbefugte Zugriffe, sondern sollen lediglich dafür sorgen, dass Nutzer bereits in der graphischen Darstellung erkennen, wozu sie berechtigt sind und worauf sie Zugriff haben.
Alles andere führt für Benutzer nur zu Verwirrung.

Für die tatsächliche Zugriffskontrolle im Back-End werden, wie bereits in der Konzeption in Abschnitt~\ref{sec:authentifizierung} erläutert, Passwörter beziehungsweise Session-IDs genutzt.
Bei der Registrierung oder einer Anmeldung wird eine solche Session-ID ausgestellt.
Bei jedem Zugriff auf einen der \acs{API}-Endpunkte wird, bevor überhaupt irgendeine Aktion ausgeführt wird, die Korrektheit dieser Session-ID geprüft.
Damit ist sichergestellt, dass eine entsprechende Prüfung nicht versehentlich beim Implementieren eines einzelnen \acs{API}-Endpunkts vergessen werden kann.
Diese entsprechende Funktion ist in Quelltext~\vref{implementation-server-auth-check} abgebildet.

\begin{lstlisting}[language=javascript, caption={Standardmäßige Authentifizierung}, label={lst:implementation-server-auth-check}]
exports.checkUserAuthorization = function (request, callback) {
	const { username, sessionId } = request.body;
	if (username === undefined || sessionId === undefined)
		return callback(false);
	db.query('SELECT * FROM users WHERE lower(username) = lower($1) AND session_id = $2;', [username, sessionId], (err, dbResult) => {
		if (err || dbResult.rows.length !== 1) {
			callback(false);
		} else if (dbResult.rows[0].password_change_required) {
			callback(false, "Error: Password change required");
		} else {
			callback(true);
		}
	});
};
\end{lstlisting}

So wird zunächst der Nutzername und die Session-ID ausgelesen.
Daraufhin kann nach einem entsprechenden Eintrag in der Datenbank gesucht werden.
Wird kein Ergebnis gefunden oder ist ein Passwortwechsel gefordert, so wird der Zugriff verwehrt.

Selbstverständlich gibt es auch \acs{API}-Endpunkte, auf die Zugriffe ohne Autorisierung möglich sein müssen.
Dies umfasst einerseits das Beantworten von Umfragen und andererseits das Registrieren, Passwortwechseln und Anmelden, bei dem Nutzer logischerweise noch keine gültige Session-ID besitzen, da sie diese ja dadurch erst erhalten wollen.
Entsprechende Ausnahmen sind über eine Whitelist gelöst, sie werden also explizit aufgelistet.
Auch hierbei steht im Vordergrund, dass \acs{API}-Endpunkte standardmäßig geschützt sind und nicht versehentlich Sicherheitslücken entstehen.

Darüber hinaus wird bei jeder Aktion die Berechtigung geprüft.
Bei der Bearbeitung eines \texttt{SurveyMasters} wird zum Beispiel zuerst einmal validiert, ob dieser auch dem angemeldeten Nutzer zugeordnet ist.
