% !TEX root =  ../../master.tex
\section{Server}

\subsection{Grundlegender Aufbau}
Zur Implementierung der Geschäftslogik wird ein Webserver mit Node.js in Verbindung mit dem Framework Express entwickelt.
Bei Node.js handelt es sich um eine JavaScript-Laufzeitumgebung, die die serverseitige Entwicklung mit JavaScript ermöglicht und dabei auf der V8-JavaScript-Implementierung von Google aufsetzt.\autocite[Vgl.][]{nl-openjsfoundation2020nodejs}
Express ist ein Framework für Node.js, um Webanwendungen und \acsp{API} zu entwickeln und wegen der Einfachheit weit verbreitet.\autocite[Vgl.][]{nl-strongloop2017express}

Für die Datenhaltung wird PostgreSQL, ein \ac{RDBMS}, verwendet.
Wie bei allen \acs{RDBMS} können Daten über die Sprache \acs{SQL} abgefragt und editiert werden. % for some unknown reason \acsp doesn't create a hyperlink here
Mithilfe eines entsprechenden Moduls kann sich innerhalb der Node.js-Anwendung mit der PostgreSQL-Datenbank verbunden werden, sodass \acs{SQL}-Befehle ausgeführt werden können.\autocite[Vgl.][]{nl-carlson2020nodepostgres}

\subsection{Implementierung der einzelnen Routen}
Für jeden \acs{API}-Endpunkt wird jeweils eine Funktion aufgerufen, die die übergebenen Daten entgegennimmt, prüft und daraufhin auf die Datenbank zugreift.
Diese Routen sind dabei am \acs{REST}-Paradigma orientiert.
Allerdings wird von diesem Muster an einigen Stellen abgewichen.
Dies hängt damit zusammen, dass die Nutzung der Schnittstelle dadurch für das Front-End bzw. den Client vereinfacht werden soll.
So kann der Client zum Beispiel neben einer Liste von Umfragen auch noch weitere Details hierzu erhalten.
Dies widerspricht zwar den Grundsätzen von \acs{REST}, reduziert allerdings den Aufwand für den Client erheblich, da je Ansicht im Front-End lediglich ein \acs{API}-Aufruf durchgeführt werden muss und nicht mehrere.

Die Routen bestehen dabei also einerseits aus den standardmäßigen und für \acs{REST} typischen Aktionen, wie zum Beispiel dem Erstellen, Lesen, Bearbeiten und Löschen von Umfragen.
Andererseits gibt es eben weitere Routen, die in enger Abstimmung mit dem Front-End erstellt wurden.
Für alle diese Routen existiert im git-Repository eine ausführliche technische Dokumentation, die genau die entsprechenden Details je Route auflistet.
Dies umfasst die Anfrage und die entsprechenden Antworten.
Je nachdem, ob eine Anfrage erfolgreich durchgeführt werden konnte oder nicht, unterscheidet sich die Antwort nämlich.
Hierfür werden \acs{HTTP}-Statuscodes genutzt, bei denen \texttt{200} zum Beispiel angibt, dass alles erfolgreich durchgeführt werden konnte.
Darüber hinaus kann dem Client so auch mitgeteilt werden, dass die Übergabeparameter ungültig waren, der Nutzen nicht autorisiert ist oder ein interner unerwarteter Fehler aufgetreten ist.\autocite[Vgl.][S. 51 ff]{nl-rfc7231}

\subsection{Zugriffskontrolle}
Die Zugriffskontrolle erfolgt im Back-End.
Da jegliche Kontrolle, die im Front-End implementiert ist, clientseitig ausgeführt wird, ist sie auch durch einen Angreifer ohne Weiteres aufzuheben und damit als unsicher anzusehen.
Nichtsdestotrotz sind natürlich auch im Front-End entsprechende Maßnahmen implementiert.
Diese dienen allerdings nicht dem Schutz gegen unbefugte Zugriffe, sondern sollen lediglich dafür sorgen, dass Nutzer bereits in der graphischen Darstellung erkennen, wozu sie berechtigt sind und worauf sie Zugriff haben.
Alles andere führt für Benutzer nur zu Verwirrung.

Für die tatsächliche Zugriffskontrolle im Back-End werden, wie bereits in der Konzeption in Abschnitt~\ref{sec:authentifizierung} erläutert, Passwörter beziehungsweise Session-IDs genutzt.
Bei der Registrierung oder einer Anmeldung wird eine solche Session-ID ausgestellt.
Bei jedem Zugriff auf einen der \acs{API}-Endpunkte wird, bevor überhaupt irgendeine Aktion ausgeführt wird, die Korrektheit dieser Session-ID geprüft.
Damit ist sichergestellt, dass eine entsprechende Prüfung nicht versehentlich beim Implementieren eines einzelnen \acs{API}-Endpunkts vergessen werden kann.

So wird dabei zunächst der Nutzername und die Session-ID ausgelesen aus der Anfrage an das Back-End ausgelesen.
Daraufhin kann nach einem entsprechenden Eintrag in der Datenbank gesucht werden.
Wird kein Ergebnis gefunden, ist die übergebene Session-ID also nicht für den entsprechenden Benutzer gespeichert, so ist der Nutzer nicht berechtigt und die Anfrage wird zurückgewiesen.
Der Zugriff wird auch dann verwehrt, wenn ein Passwortwechsel gefordert ist.
Somit wird dieser Passwortwechsel, z.~B. nach einem Zurücksetzen des Passworts, durchgesetzt und kann nicht umgangen werden.

Selbstverständlich gibt es auch \acs{API}-Endpunkte, auf die Zugriffe ohne Autorisierung möglich sein müssen.
Dies umfasst einerseits das Beantworten von Umfragen und andererseits das Registrieren, Passwortwechseln und Anmelden, bei dem Nutzer logischerweise noch keine gültige Session-ID besitzen, da sie diese ja dadurch erst erhalten wollen.
Entsprechende Ausnahmen sind über eine Whitelist gelöst, sie werden also explizit aufgelistet.
Auch hierbei steht im Vordergrund, dass \acs{API}-Endpunkte standardmäßig geschützt sind und nicht versehentlich Sicherheitslücken entstehen.

Darüber hinaus wird bei jeder Aktion die Berechtigung geprüft.
Bei der Bearbeitung eines \texttt{SurveyMasters} wird zum Beispiel zuerst einmal validiert, ob dieser auch dem angemeldeten Nutzer zugeordnet ist.

Ebenso gibt es Aktionen, die nur durch Administratoren durchgeführt werden können.
Dies umfasst das Lesen, Aktivieren, Bearbeiten und Deaktivieren des Registrierungsschlüssels, das Erstellen von Benutzern, das Zurücksetzen von Passwörtern und das Erstellen weiterer Administratoren.
Hierbei wird folglich vor dem Ausführen irgendeiner Aktion geprüft, ob der angemeldete Nutzer in der Datenbank als Administrator gekennzeichnet ist.
